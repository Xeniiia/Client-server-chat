//Библиотеки для сокета:
#include <sys/types.h>
#include <sys/socket.h>
//Библиотека для perror()
#include <stdio.h>
//Библиотека для exit
#include <stdlib.h>
//Библиотека для sockaddr_in
#include <netinet/in.h>
//Для bind?
#include <arpa/inet.h>
//Для read
#include <unistd.h>

//ФУНКЦИЯ ПРОВЕРКИ НА ВОЗВРАЩЕНИЕ ОШИБКИ СОКЕТОМ
int Socket(int domian, int type, int protocol) {	//Те же константы, что и у функции сокета из библиотеки <sys/socket.h>
	int res = socket(domian, type, protocol); 		//Это просто вызов сокета
	if (res == -1) { 								//Если сокет вернул -1, то возникла ошибка
		perror("socket failed"); 					//Тогда печатаем ошибку и выходим из программы
		exit(EXIT_FAILURE);
	}
	return res; 									//Иначе вернем результат работы сокета
}

//ФУНКЦИЯ ПРОВЕРКИ НА ВОЗВРАЩЕНИЕ ОШИБКИ БИНДОМ
void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {//Те же константы
	int res = bind(sockfd, addr, addrlen);
	if (res == -1) { 					//Если вернул -1, то возникла ошибка
		perror("bind failed"); 			//Тогда печатаем ошибку и выходим из программы
		exit(EXIT_FAILURE);
	}
}

//ФУНКЦИЯ ПРОВЕРКИ НА ВОЗВРАЩЕНИЕ ОШИБКИ ПРИ СЛУШАНИИ (кек)
void Listen(int sockfd, int backlog) {	//Те же константы
	int res = listen(sockfd, backlog);
	if (res == -1) { 					//Если вернул -1, то возникла ошибка
		perror("listen failed"); 		//Тогда печатаем ошибку и выходим из программы
		exit(EXIT_FAILURE);
	}
}

//ФУНКЦИЯ ПРОВЕРКИ НА ВОЗВРАЩЕНИЕ ОШИБКИ ПРИ ПРИЕМЕ
void Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {//Те же константы
	int res = accept(sockfd, addr, addrlen);
	if (res == -1) { 					//Если вернул -1, то возникла ошибка
		perror("accept failed"); 		//Тогда печатаем ошибку и выходим из программы
		exit(EXIT_FAILURE);
	}
	return res;							//Иначе вернем результат работы
}

int main() {
	cout >> "Начало";
	//-----------------------Создадим сокет.--------------------------------------
	//Первая константа означает семейство протоколов,
	//которое будет использоваться,
	//в моем случае это IPv4

	//Вторая константа означает протокол,
	//в моем случае это TCP 
	//(передающиеся данные будут точно доставлены и в нужной последовательности)

	//Также может использоваться протокол UDP, но он не гарантирует отсутствие потерь при передаче
	int server = Socket(AF_INET, SOCK_STREAM, 0);

	struct sockaddr_in adr = {0};	//Структура для задачи адреса по протоколу IPv4, заполним нулями
	adr.sin_family = AF_INET; 		//Задаем семейство адресов
	adr.sin_port = htons(34543);	//Порт, на котором сервер будет слушать (htons = хост к сети, host to network short value), влияет на порядок байтов
	Bind(server, (struct sockaddr *) &adr, sizeof adr);	//Выполним привязку сокета к адресу

	Listen(server, 5);				//Слушать на сокете server, до 5ти клиентов может слушать
	printf("Сервер запущен\n");
	socklen_t adrlen = sizeof adr;	//Неизвестная мне переменная типа socklen_t которая вроде как означает размер чего-то (надо погуглить)

	//Прием клиента (кек)
	//Вернет дескриптор принятого сокета, по которому можно вновь обратиться к этому клиенту:
	int fd = Accept(server, (struct sockaddr *) &adr, &adrlen);

	//Прочитаем сообщение, посланное клиентом
	ssize_t nread;				//какая-то страннная переменная типа ssize_t спасибо разрабам за классные названия
	char buf[256];				//Сообщение не длиннее 256 char-ов
	nread = read(fd, buf, 256); //В эту переменную записывается количество байт сообщения
	//Если вернет -1 значит ошибка
	if (nread == -1) {
		perror("read failed"); //напечатаем ошибку и выйдем (вон) из программы
		exit(EXIT_FAILURE);
	}
	//Иначе вернет количество принятых байт и 0 если клиент больше не будет ничего писать (но он еще может принимать!)
	//(хотя не факт, что вернет сразу все байты, ну да не важно, зато не -1)
	if (nread == 0) {	//Если равно 0, то клиент больше не будет писать
		printf("Конец файла\n"); //Напечатаем это в консоли
	}
	//И еще напечатаем
	write(STDOUT_FILENO, buf, nread);	//Чтобы знать

	//Передадим на клиент ответ (то же самое)
	write(fd, buf, nread);
	//Тута можно уже было бы и закончить с сокетом командами ниже, но нет
	// close(fd);
	// close(listen);
	//return 0;
}