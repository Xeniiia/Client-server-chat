//Файл сервера

//для правильной работы inet_addr:
#define _WINSOCK_DEPRECATED_NO_WARNINGS
//для работы WinSock:
#pragma comment(lib, "ws2_32.lib")
#include <winsock2.h>
#include <iostream>
using namespace std;

int ClientCount = 0;                    //количество подключенных к серверу клиентов
SOCKET* Connections;                    //для нескольких подключений
void SendMessageToClient(int ID);       //Объявление функции

int main(int args, char* argv[])
{
    //-----------Загрузка библиотеки для работы с сокетами---------------------------
    WSAData wsaData;                                        //Создадим структуру WSAData
    WORD DLLVersion = MAKEWORD(2, 1);                       //Запрашивается версия для библиотеки WinSock
    if (WSAStartup(DLLVersion, &wsaData) != 0) {            //Загрузка нужной библиотеки, если вернул не ноль - ошибка
        cout << "Error: WinSock does not install" << endl;  //выведем сообщение об ошибке
        exit(1);                                            //если ошибка - выход
    }
    else cout << "WinSock was install!" << endl;            //Уведомим сообщением об удачной загрузке библиотеки
    Connections = (SOCKET*)calloc(64, sizeof(SOCKET));      //Выделяем память под потоки и пользователей
    //-------------------------------------------------------------------------------

    //----------Заполнение информации об адресе сокета-------------------------------
    SOCKADDR_IN addr;                                       //Структура SOCKADDR предназначена для хранения адреса, 
                                                            //_IN используется для интернет-протоколов, addr - название переменной

    addr.sin_addr.s_addr = inet_addr("127.0.0.1");          //sin_addr - структура SOCKADDR_IN, хранящая IP-адресс, s_addr = сеттер адреса. 127.0.0.1 - локальный хост (собственный компьютер)
    addr.sin_port = htons(8000);                            //sin_port - порт для идентификации порта с поступающими данными, htons - способ обработки (?) "хост к сети" 
                                                            //(host to network short value). 8000 - рандомное значение порта (главное меньше 1024, они зарезервированы системой)
    addr.sin_family = AF_INET;                              //sin_family - семейство протоколов, AF_INET - константа
    
    cout << "A socket was created." << endl;                //Уведомим о создании сокета-сервера
    //-------------------------------------------------------------------------------

    //----------Запуск прослушивания порта (сервер ждет клиентов)--------------------
    SOCKET sListen = socket(AF_INET, SOCK_STREAM, NULL);    //Создание сокета с названием sListen, присваивается значение функции socket
                                                            //Функция socket создает сокет, привязанный к определенному поставщику транспортных услуг
                                                            //В функцию передаются параметры: семейство протоколов, сам протокол, третий параметр не нужен - поэтому NULL
                                                            //SOCK_STREAM -  протокол TCP (значит все сообщения будут точно доставлены и в нужной посл-ти)
    
    //Привязка адреса к сокету:
    bind(sListen, (SOCKADDR*)&addr, sizeof(addr));          //Сам сокет, который надо привязать, адрес сокета, к которому привязать, и размер этого адреса  - параметры
    //Прослушивание порта в ожидании соединения клиента:
    listen(sListen, 64);                                    //Сокет с адресом (по его данным запускается прослушивание), максимальное количество клиентов (в очереди)
    cout << "Waiting for clients to connect...\n";
    //-------------------------------------------------------------------------------


    //---------Уведомление о подключении---------------------------------------------
    char message[MAX_PATH];
    const char* m_connect = "Server's message: You connected!"; //приветственное сообщение об удачном подключении
    //-------------------------------------------------------------------------------


    //---------Подключение нескольких клиентов:--------------------------------------
    SOCKET newConnection;                                                       //Создадим новый сокет для подключения клиентов
    int sizeofaddr = sizeof(addr);                                              //Вспомогательная переменная, чтобы не выдавало ошибку ниже, запоминаем размер адреса сокета-сервера

    while (true) {                                                              //Бесконечный цикл

        if (newConnection = accept(sListen, (SOCKADDR*)&addr, &sizeofaddr)) {   //Если клиент удачно подключился. (ПЕРЕМЕННЫЕ (SOCKADDR*)&addr, &sizeofaddr ЯВЛЯЮТСЯ НЕ ОБЯЗАТЕЛЬНЫМИ И МОГУТ БЫТЬ NULL)
            cout << "Client connected!" << endl;                                //Вывести сообщение об этом
            Connections[ClientCount] = newConnection;                           //создается SOCKET с номером [ClientCount], который находится в Connections[ClientCount]
            send(Connections[ClientCount], m_connect, MAX_PATH, NULL);          //Новому пользователю отправляется приветственное сообщение об удачном подключении

            ClientCount++;                                                      //Количество подключенных клиентов +1

            //Чтобы клиент мог подключаться и пользоваться чатом не один:
            CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)SendMessageToClient, (LPVOID)(ClientCount - 1), NULL, NULL); //создание нового потока
                                        //NULL нам не нужно, (LPTHREAD_START_ROUTINE)SendMessageToClient - выполняемая функция при создании потока
                                        //(LPVOID)(ClientCount - 1) - передаваемая переменная в поток
                                        //т.е. Создается поток, выполняющий функцию SendMessageToClient (см. ниже), где "(LPTHREAD_START_ROUTINE)" приведение к нужному типу
                                        //В поток передается количество клиентов-1, где (LPVOID) опять же приведение к нужному типу

        } else cout << "Error: client could not connect" << endl;                //Если клиент не смог подключиться - печатаем сообщение о неудаче
        cout << "Count of clients = " << ClientCount << endl;                    //Выведем количество подключенных клиентов
    }
    //-------------------------------------------------------------------------------

    system("pause");
    return 0;
}

//-------------Функция отправки полученного сообщения ВСЕМ клиентам:-----------------
void SendMessageToClient(int ID) {
    char* buffer = new char[260];                               //Указатель на буфер для сообщения, размером 256
    for (;;Sleep(75)) {                                         //Каждые 75 милисекунд (чтобы процессоры освобождались)
        if (recv(Connections[ID], buffer, MAX_PATH, NULL)) {    //принимаем сообщения от клиента

            if (buffer[0] == '!' and buffer[1] == '!') {            //Проверка, не вышел ли клиент. Если его сообщение начинается с !!
                cout << "User #" << ID << " disconnected" << endl;  //Выведем сообщение о том, то этот клиент вышел
                break;                                              //Выйдем из функции
            }
            
            else {                                                      //Иначе, если клиент не отправлял сообщение об отключении
                cout << "User #" << ID << " send: " << buffer << endl;  //выводит его сообщение в консоли сервера
                for (int i = 0; i <= ClientCount; ++i) {                //Цикл по количеству подключенных клиентов
                    send(Connections[i], buffer, MAX_PATH, NULL);       //Отправляет полученное сообщение от одного клиента всем подключенным клиентам
                }
            }
        }
        ZeroMemory(buffer, sizeof(buffer));                         //Обнуляем буфер с сообщением
    }
}
//-----------------------------------------------------------------------------------