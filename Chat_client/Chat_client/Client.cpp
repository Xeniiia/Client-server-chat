//Файл клиента

//для правильной работы inet_addr:
#define _WINSOCK_DEPRECATED_NO_WARNINGS
//для работы WinSock:
#pragma comment(lib, "ws2_32.lib")
#include <winsock2.h>
#include <iostream>
using namespace std;

SOCKET Connection;          //Объявление сокета глобально, чтобы мы могли обращаться к нему в функции вне main
void RecvToClient();        //Объявление функций
void getWord(char* mas);    //

int FLAG = 0;               //Эта глобальная переменная "костыль", который понадобится после (см. Прием сообщений от других и Ввод сообщений от клиента)
int FLAG_for_disconnect = 0;//Глобальная переменная-флаг для того, чтобы задушить этот поток в дальнейшем. 0 - клиент еще тут, 1 - клиент собрался выйти из чата.

int main(int args, char* argv[])
{
    //-----------Загрузка библиотеки для работы с сокетами---------------------------
    WSAData wsaData;                                        //Создадим структуру WSAData
    WORD DLLVersion = MAKEWORD(2, 1);                       //Запрашивается версия для библиотеки WinSock
    if (WSAStartup(DLLVersion, &wsaData) != 0) {            //Загрузка нужной библиотеки, если вернул не ноль - ошибка
        cout << "Error: WinSock does not install" << endl;  //выведем сообщение об ошибке
        exit(1);                                            //если ошибка - выход
    }
    else cout << "WinSock was install!" << endl;            //Если библиотека успешно установлена - сообщим об этом
    //-------------------------------------------------------------------------------

    //----------Заполнение информации об адресе сокета:------------------------------
    SOCKADDR_IN addr;                               //Структура SOCKADDR предназначена для хранения адреса, 
                                                    //_IN используется для интернет-протоколов, addr - название переменной

    addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //sin_addr - структура SOCKADDR_IN, хранящая IP-адресс, s_addr = сеттер адреса. 127.0.0.1 - локальный хост (собственный компьютер)
    addr.sin_port = htons(8000);                    //sin_port - порт для идентификации порта с поступающими данными, htons - способ обработки
                                                    //8000 - рандомное значение порта (главное не меньше 1024, они зарезервированы системой)
    addr.sin_family = AF_INET;                      //sin_family - семейство протоколов, AF_INET - константа

    cout << "A socket was created." << endl;        //Сообщим о создании сокета
    //-------------------------------------------------------------------------------

    //---------Создание нового сокета для соединения с сервером----------------------
    Connection = socket(AF_INET, SOCK_STREAM, NULL);
    //-------------------------------------------------------------------------------

    //---------Создание потока для этого клиента:------------------------------------
    char message[MAX_PATH];                                         //Массив char для сообщения, отправляемого клиентом. MAX_PATH = 260, константа

    while (1) {                                                     //Бесконечный цикл для создания новых потоков
        if (connect(Connection, (SOCKADDR*)&addr, sizeof(addr))) {  //Если к сокету подключился клиент (этот самый, выполняемый)
            recv(Connection, message, sizeof(message), 0);          //Принять сообщение от сервера (приветственное, об удачном подключении)
            cout << message << endl;                                //Вывести сообщение, полученное от сервера (приветсвенное сообщение)
            CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecvToClient, NULL, NULL, NULL); //Создать поток, слушающий сервер
            break;                                                  //После создания потока выйти из цикла
        } 
    }
    //-------------------------------------------------------------------------------

    
    //----------Ввод сообщений клиентом:---------------------------------------------
    ZeroMemory(message, sizeof(message));                               //Заполним нулями массив message (бывшее приветственное сообщение), 
                                                                        //чтобы использовать для отправки своих сообщений

    cout << "To disconnect send: !!" << endl;                           //Сообщение-инструкция о том, как выйти из чата
    cout << "You can send your message. Press Enter to send: "<<endl;   //Вывести инструкцию для клиента
    while (1) {                                                         //Входим в бесконечный цикл
        Sleep(200);                                                     //Ждем 200 милисекунд, чтобы сначала печаталось сообщение от других, а потом уже
                                                                        //разрешался ввод сообщения для клиента
        getWord(message);                                               //Функция, которая получает из консоли сообщение этого клиента

        if (message[0] == '!' and message[1] == '!') {                          //Проверка, не выходит ли из чата клиент. Если он отправил сообщение для отключения (!!)
            send(Connection, message, MAX_PATH, 0);                             //Отправляем это сообщение на сервер (он должен знать, что пользователь отключился).
            cout << "You have succesfully disconnected. Good bye!" << endl;     //Напечатаем клиенту об удачном отключении
            FLAG_for_disconnect = 1;                                            //Установим флаг, чтобы выйти из функции, вызванной потоком
            break;                                                              //выйдем из этого бесконечного цикла
        }
        else                                                                //Если же клиент не отправлял сообщение для отключения
        {
            cout << "\033[A\33[2K\r -  You: " << message << endl;           //"\033[A\33[2K" - подняться на строку выше, "\r" - вернуться в начало строки. " - You:" печатается поверх
                                                                            //предыдущей строки (то есть ввод сообщения клиентом), перекрывая его
            FLAG = 1;                                                       //КОСТЫЛЬ устанавливаем флаг 1 (т.е. было отправлено сообщение клиентом). 
                                                                            //См ниже в "Прием сообщений от других", что оно делает.
            send(Connection, message, MAX_PATH, 0);                         //Отправляем это сообщение на сервер.
            ZeroMemory(message, sizeof(message));                           //Очищаем массив сообщения (чтобы можно было набрать новое)
        }
    }
    //-------------------------------------------------------------------------------

 
    closesocket(Connection);    //Закроем сокет
    WSACleanup();               //Освободим память
    system("pause");            
    return 0;                   
}

//---------Прием сообщений от других:------------------------------------------------
void RecvToClient() {
    char* buffer = new char[260];                       //Массив, в который будет записываться принятое сообщение
    for (;; Sleep(75)) {                                //Каждые 75 милисекунд

        if (FLAG_for_disconnect == 1) break;            //Если пользователь отключился (флаг 1 стал после того, как пользователь отправил !!) - выйти из функции (поток завершается)

        else {                                          //Иначе (если пользователь не отключен), то
        ZeroMemory(buffer, sizeof(buffer));             //Обнулим массив (уберем мусор и предыдущие сообщения)
        if (recv(Connection, buffer, 260, NULL)) {      //Если было принято сообщение от сокета-сервера (сообщение записывается в buffer, длиной до 260)

            if (FLAG == 0 and FLAG_for_disconnect == 0) {   //Если ФЛАГ 0 (т.е. если было принято сообщение от ДРУГОГО пользователя) и пользователь не отключился
                cout << " - User: " << buffer << endl;      //Напечатать это сообщение
            }
            FLAG = 0;
            //Обнулить флаг (Значит, предыдущее собщение было принято от ДРУГОГО пользователя)
            //Если флаг = 1 (см. "Ввод сообщений клиентом") - значит последнее отправленное сообщение было ОТ ЭТОГО КЛИЕНТА
            //и печатать его как сообщение от другого пользователя НЕ НАДО!
            //т.е. так как сервер рассылает всем клиентам принятые сообщения, то этот клиент получит СВОЕ сообщение в формате " - User:"
            //как чужое. Но его НЕ НАДО ПЕЧАТАТЬ КАК ЧУЖОЕ. Для понимания, чье сообщение пришло - клиента или другого пользователя,
            //используется флаг. Каждый раз при отправке СВОЕГО сообщения флаг=1. Значит здесь полученное сообщение от сервера не выводится
            //(так как мы выводим это сообщение в "Ввод сообщений клиентом" с пометкой " - You:")
            //После каждого принятого сообщения флаг снова обнуляется.
            }
        }
    }
}
//----------------------------------------------------------------------------------

//---------Чтение введенного сообщения клиентом:------------------------------------
void getWord(char* mas) {
    int c;                                              //Макрос getchar() возвращает очередной символ из файла stdin типа unsigned char, преобразованный к целому. 
                                                        //При считывании маркера конца файла возвращается EOF (End Of File).
    for (int i = 0; (c = getchar()) != EOF && c != '\n'; ++i)   //Пока считанный символ не конец строки и не переход на новую строку
        mas[i] = c;                                             //и-тый элемент - этот символ
}
//----------------------------------------------------------------------------------